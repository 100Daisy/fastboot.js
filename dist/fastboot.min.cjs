"use strict";function e(...e){console.log(...e)}function t(e){return new Promise(((t,i)=>{let n=new FileReader;n.onload=()=>{t(n.result)},n.onerror=()=>{i(n.error)},n.readAsArrayBuffer(e)}))}Object.defineProperty(exports,"__esModule",{value:!0});const i=new Map;i.set(51905,"raw"),i.set(51906,"fill"),i.set(51907,"skip");class n extends Error{constructor(e){super(e),this.name=this.constructor.name}}function a(e){let t=new DataView(e);if(3978755898!==t.getUint32(0,!0))return null;let i=t.getUint16(4,!0),a=t.getUint16(6,!0);if(1!==i||a<0)throw new n(`Unsupported sparse image version ${i}.${a}`);let s=t.getUint16(8,!0),r=t.getUint16(10,!0);if(28!==s||12!==r)throw new n(`Invalid file header size ${s}, chunk header size ${r}`);let l=t.getUint32(12,!0);if(l%4!=0)throw new n(`Block size ${l} is not a multiple of 4`);return{blockSize:l,blocks:t.getUint32(16,!0),chunks:t.getUint32(20,!0),crc32:t.getUint32(24,!0)}}function s(e){let t=new DataView(e);return{type:i.get(t.getUint16(0,!0)),blocks:t.getUint32(4,!0),dataBytes:t.getUint32(8,!0)-12,data:null}}function r(e){return e.map((e=>e.blocks)).reduce(((e,t)=>e+t),0)}function l(e){return 28+12*e.length+function(e){return e.map((e=>e.data.byteLength)).reduce(((e,t)=>e+t),0)}(e)}function o(e,t){let i=new ArrayBuffer(l(t)),a=new DataView(i),s=new Uint8Array(i);a.setUint32(0,3978755898,!0),a.setUint16(4,1,!0),a.setUint16(6,0,!0),a.setUint16(8,28,!0),a.setUint16(10,12,!0),a.setUint32(12,e.blockSize,!0),a.setUint32(16,e.blocks,!0),a.setUint32(20,t.length,!0),a.setUint32(24,0,!0);let r=28;for(let e of t){let t;if("raw"==e.type)t=51905;else if("fill"==e.type)t=51906;else{if("skip"!=e.type)throw new n(`Invalid chunk type "${e.type}"`);t=51907}a.setUint16(r,t,!0),a.setUint16(r+2,0,!0),a.setUint32(r+4,e.blocks,!0),a.setUint32(r+8,12+e.data.byteLength,!0),r+=12;let i=new Uint8Array(e.data);s.set(i,r),r+=e.data.byteLength}return i}class c extends Error{constructor(e){super(e),this.name=this.constructor.name}}class d extends Error{constructor(e,t){super(`Bootloader replied with ${e}: ${t}`),this.status=e,this.bootloaderMessage=t,this.name=this.constructor.name}}class h{constructor(){this.db=null}async _wrapReq(e,t=null){return new Promise(((i,n)=>{e.onsuccess=()=>{i(e.result)},e.oncomplete=()=>{i(e.result)},e.onerror=e=>{n(e)},null!==t&&(e.onupgradeneeded=t)}))}async init(){this.db=await this._wrapReq(indexedDB.open("BlobStore",1),(e=>{e.target.result.createObjectStore("files",{keyPath:"name"})}))}async saveFile(e,t){this.db.transaction(["files"],"readwrite").objectStore("files").add({name:e,blob:t})}async loadFile(e){try{return(await this._wrapReq(this.db.transaction("files").objectStore("files").get(e))).blob}catch(e){return null}}async close(){this.db.close()}}async function u(e,t,i,n){i("unpack",n);let a=await t.getData(new zip.BlobWriter("application/octet-stream"));i("flash",n),await e.flashBlob(n,a)}var w=Object.freeze({__proto__:null,downloadZip:async function(t){let i=new h;await i.init();let n=t.split("/").pop(),a=await i.loadFile(n);if(null==a){e(`Downloading ${t}`);let s=await fetch(new Request(t));a=await s.blob(),e("File downloaded, saving..."),await i.saveFile(n,a),e("File saved")}else e(`Loaded ${n} from blob store, skipping download`);return i.close(),a},flashZip:async function(t,i,n=(()=>{})){let a=new h;await a.init(),e(`Loading ${i} as zip`);let s=new zip.ZipReader(new zip.BlobReader(await a.loadFile(i))),r=await s.getEntries();for(let i of r)if(i.filename.match(/avb_pkmd.bin$/))e("Flashing AVB custom key"),await u(t,i,n,"avb_custom_key");else if(i.filename.match(/bootloader-.+\.img$/))e("Flashing bootloader image pack"),await u(t,i,n,"bootloader");else if(i.filename.match(/radio-.+\.img$/))e("Flashing radio image pack"),await u(t,i,n,"radio");else if(i.filename.match(/image-.+\.zip$/)){e("Flashing images from nested images zip");let a=await i.getData(new zip.BlobWriter("application/zip")),s=new zip.ZipReader(new zip.BlobReader(a));for(let i of await s.getEntries()){if(!i.filename.endsWith(".img"))continue;e(`Flashing ${i.filename} from images zip`);let a=i.filename.replace(".img","");await u(t,i,n,a)}}a.close()}});exports.Factory=w,exports.FastbootDevice=class{constructor(){this.device=null}get isConnected(){return null!==this.device}async connect(){this.device=await navigator.usb.requestDevice({filters:[{classCode:255,subclassCode:66,protocolCode:3}]}),e("Got USB device:",this.device);let t=this.device.configurations[0].interfaces[0].alternates[0];if(2!==t.endpoints.length)throw new c("Interface has wrong number of endpoints");let i=null,n=null;for(let a of t.endpoints){if(e("Checking endpoint:",a),"bulk"!==a.type)throw new c("Interface endpoint is not bulk");if("in"==a.direction){if(null!=i)throw new c("Interface has multiple IN endpoints");i=a.endpointNumber}else if("out"==a.direction){if(null!=n)throw new c("Interface has multiple OUT endpoints");n=a.endpointNumber}}e("Endpoints: in =",i,", out =",n),await this.device.open();try{await this.device.reset()}catch(e){}await this.device.selectConfiguration(1),await this.device.claimInterface(0)}async _readResponse(){let t,i={text:"",dataSize:null};do{let n=await this.device.transferIn(1,64);if(t=(new TextDecoder).decode(n.data),e("response: packet",n,"string",t),t.startsWith("OKAY"))i.text+=t.substring(4);else if(t.startsWith("INFO"))i.text+=t.substring(4)+"\n";else{if(!t.startsWith("DATA"))throw new d(t.substring(0,4),t.substring(4));i.dataSize=t.substring(4)}}while(t.startsWith("INFO"));return i}async runCommand(t){if(t.length>64)throw new RangeError;let i=new TextEncoder("utf-8").encode(t);return await this.device.transferOut(1,i),e("command:",t),this._readResponse()}async getVariable(e){let t=(await this.runCommand(`getvar:${e}`)).text;if(t=t.trim(),t)return t;throw new d("FAIL","No such variable (OKAY)")}async _getDownloadSize(){try{let e=(await this.getVariable("max-download-size")).toLowerCase();if(e)return Math.min(parseInt(e,16),1073741824)}catch(e){}return 536870912}async _sendRawPayload(t){let i=0,n=t.byteLength;for(;n>0;){let a=t.slice(16384*i,16384*(i+1));i%1e3==0&&e(`  Sending ${a.byteLength} bytes to endpoint, ${n} remaining, i=${i}`),await this.device.transferOut(1,a),n-=a.byteLength,i+=1}e(`Finished sending payload, ${n} bytes remaining`)}async _flashSingleSparse(t,i){e(`Flashing single sparse to ${t}: ${i.byteLength} bytes`);let n=i.byteLength.toString(16).padStart(8,"0");if(8!==n.length)throw new d("FAIL",`Transfer size overflow: ${n} is more than 8 digits`);let a=await this.runCommand(`download:${n}`);if(null==a.dataSize)throw new d("FAIL",`Unexpected response to download command: ${a.text}`);if(parseInt(a.dataSize,16)!==i.byteLength)throw new d("FAIL",`Bootloader wants ${i.byteLength} bytes, requested to send ${i.bytelength} bytes`);e(`Sending payload: ${i.byteLength} bytes`),await this._sendRawPayload(i),e("Payload sent, waiting for response..."),await this._readResponse(),e("Flashing payload..."),await this.runCommand(`flash:${t}`)}async flashBlob(i,n){try{"yes"==await this.getVariable(`has-slot:${i}`)&&(i+="_"+await this.getVariable("current-slot"))}catch(e){}let c=await this._getDownloadSize(),d=await t(n.slice(0,28));if(n.size>c&&!function(e){try{return null!==a(e)}catch(e){return!1}}(d)){e(`${i} image is raw, converting to sparse`);let a=function(e){let t={blockSize:4096,blocks:e.byteLength/4096,chunks:1,crc32:0},i=[];for(;e.byteLength>0;){let n=Math.min(e.byteLength,67108864);i.push({type:"raw",blocks:n/t.blockSize,data:e.slice(0,n)}),e=e.slice(n)}return o(t,i)}(await t(n));n=new Blob([a])}e(`Flashing ${n.size} bytes to ${i}, ${c} bytes per split`);let h=0;for await(let d of async function*(i,n){if(e(`Splitting ${i.size}-byte sparse image into ${n}-byte chunks`),i.size<=n)return e("Blob fits in 1 payload, not splitting"),void(yield await t(i));let c=a(await t(i.slice(0,28)));c.crc32=0,i=i.slice(28);let d=[];for(let a=0;a<c.chunks;a++){let h=s(await t(i.slice(0,12)));h.data=await t(i.slice(12,12+h.dataBytes)),i=i.slice(12+h.dataBytes);let u=n-l(d);if(e(`  Chunk ${a}: type ${h.type}, ${h.dataBytes} bytes / ${h.blocks} blocks, ${u} bytes remaining`),u>=h.dataBytes)e("    Space is available, adding chunk"),d.push(h);else{let t=r(d);d.push({type:"skip",blocks:c.blocks-t,data:new ArrayBuffer}),e(`Partition is ${c.blocks} blocks, used ${t}, padded with ${c.blocks-t}, finishing split with ${r(d)} blocks`);let i=o(c,d);e(`Finished ${i.byteLength}-byte split with ${d.length} chunks`),yield i,e(`Starting new split: skipping first ${t} blocks and adding chunk`),d=[{type:"skip",blocks:t,data:new ArrayBuffer},h]}}if(d.length>0&&(d.length>1||"skip"!==d[0].type)){let t=o(c,d);e(`Finishing final ${t.byteLength}-byte split with ${d.length} chunks`),yield t}}(n,c))await this._flashSingleSparse(i,d,c),h+=1;e(`Flashed ${i} with ${h} split(s)`)}};
